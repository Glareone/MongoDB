# Introduction 
This is a repo created for storing any useful information about MongoDB.

<details>
<summary>Section - 1: Introduction</summary>

* MongoDB Data structure:  

![mongoDB](Section-1/intro-structure.jpg)

* MongoDB data format (document-oriented storage format):

![data-format](Section-1/2-data-format.jpg)

* BSON data-format and what is under the hood:

![BSON](Section-1/3-no-schema.jpg)

* MongoDB Ecosystem:

![Ecosystem](Section-1/4-ecosystem.jpg)

* Work with MongoDB:

![mongodb](Section-1/9-work-with-mongo.jpg)
![mongodb2](Section-1/10-inside.jpg)

* Implicit operations in Mongo:

![console output](Section-2/1-implicit.jpg)

## Start working with MongoDB

To add mongo command to your command line:  
<b> win - environment variables - advanced tab - environment variables</b>  
Add here a path to your mongoDB.
![image how to do that](Section-1/5-cmd-configuration.jpg)

[useful link](https://dangphongvanthanh.wordpress.com/2017/06/12/add-mongos-bin-folder-to-the-path-environment-variable/)

<b>BTW</b>, to continue working with course you have to stop MongoDB service and start db manually
using "mongo" command from console. Without it "mongo" command will open mongo service instead of real db.

to stop service - open CMD as admin and `net stop Mongo`

<b>Last step:</b>  
* To make default data storage location: create "data" folder in C: drive and put folder "db" within.
* Otherwise: create another directory (i.e. D:\mongodb-data\db) and put command in cmd:
`mongod --dbpath D:\mongodb-data\db`

<b>Pay attention:</b>
You have to leave your process running (cmd console should be opened) to work with mongoDB service.

* CMD - `mongo`

And now you are in the mongo shell where you can run your commands and queries.
</details>

<details>
<summary>Section - 1: Simple commands</summary>

* `show dbs` - will show existing dbs in selected repository (`--dbpath D:\mongodb-data\db`)
* `use Your_db_name` - will switch to db with selected name. If db does not exist - it will create it automatically.
* `db.products.insertOne({name: "A Book", price: 29.99})` - will create a table named products (it does not exist too) 
in db which we connected to and insert a document inside it.  
Pay attention on non-existing quotation mark in "keys" - you can use key naming without quotations, they will be added
under the hood.  

Here is a console output. InsertedId - generated uniqueId for this insert, acknowledged - verified that this data was inserted.
![console output](Section-1/7-console-output-after-insert.jpg)

* `db.products.find()` - retrieves you all data from collection (from table in SQL world).
* `db.products.find().pretty()` - show this data formatted.
![pretty](Section-1/8-find-pretty.jpg)
</details>

<details>
<summary>Section - 2: JSON-vs-BSON, Basics & CRUD operations</summary>

### Summary
![summary](Section-2/24-Summary.jpg)

### Json vs Bson:
![json-vs-bson](Section-2/2-json-vs-bson.jpg)

* You can set _id field manually and do not rely on autogenerated id.
BTW, you can't insert another document with the same _id.

![id](Section-2/3-_id-field.jpg)

## CRUD Operations:

![crud](Section-2/4-crud-1.jpg)
![crud](Section-2/5-crud-2.jpg)

### Read 
Simple filter: `db.flight.find({intercontinental: true}).pretty()`;
Greater than ($gt): `db.flight.find({distance: {$gt: 10000}}).pretty()`;
FindOne: `db.flight.findOne({distance: {$gt: 10000}})`

### InsertMany and Show results using find. Cursor  
Find does not show you all results, it shows you a cursor by default:  
![cursor](Section-2/11-insert-many.jpg)
![cursor](Section-2/12-find-cursor.jpg)

* Bare in mind that mongodb will increment Id to keep the proper element's order. First came element will contain minor identifier:

![crud](Section-2/6-insert-many.jpg)

### UpdateOne
`db.flight.updateOne({distance: 12000}, {$set: {marker: "new field delete"}})` - will update first document which contains distance: 12000.  
Pay attention on <b>$set</b> - all reserved words start from dollar sign. 
This operator means that you would like to update your document with new field.

### UpdateMany
`db.flight.updateMany({}, {$set: {marker: "to Delete!"}})` - empty curly braces `{}` mean all documents in collection.

### Update
`update` operation works like `updateMany`:  
![crud](Section-2/7-update.jpg)

As you may have noticed first modification using set to `delayed: true` has no modified results because our document already
has this value. When we changed the value to false - log shows us that our value has been changed.

The difference between them - you can use it without `$set` operator, update does accept this syntax.
But it works on another manner:
![crud](Section-2/8-update-2.jpg)

It will override all key-value pairs in document!
![crud](Section-2/9-update-3.jpg)

It works very close to `replaceOne`:
![crud](Section-2/10-replaceone.jpg)

### Delete
`db.flight.deleteOne({departureAirport: "TXL"})` - departureAirport: "TXL" will be used as filter to find what exactly
 we want to delete from collection. Only first found document with "TXL" will be deleted.

### forEach
It is possible to use .forEach operation after find() to do something with every element after filtering:
`db.passengers.find().forEach((passengerData) => {printjson(passengerData)})` - bare in mind forEach uses syntax according
your MongoDB driver. Shell uses Nodejs syntax.

Pay attention:
That's why you cant use `pretty()` after findOne() method - `pretty()` is a method of a Cursor, findOne does not return cursor,
(and `pretty()` does not exist for a single value), findOne returns a sole value.

</details>

<details>
<summary>Section - 2: Projection</summary>

### Projection
Projection means a mechanism to avoid overfetching from database.  
You can use it as a parameter in `find` method:
* `find({}, {name: 1})` - first parameter is a filter, the second is projection. 1 means - "include this data".

![projection](Section-2/13-projection-overfetching.jpg)
![projection](Section-2/14-projection-2.jpg)

By default it will send you objects with _id (because it is a default property) and "name".

* To exclude _id (or any other field) - `find({}, {_id: 0})` - 0 means exclude.
![projection](Section-2/15-projection-3.jpg)

To only name - `find({}, {name: 1, _id: 0})`/

</details>

<details>
<summary>Section - 2: Embedded Documents & Arrays</summary>

![embedded](Section-2/16-Embedded-doc.jpg)
![embedded](Section-2/17-Embedded-array.jpg)

## Array examples:
![arrays](Section-2/18-embedded-doc-example.jpg)
![arrays](Section-2/19-embedded-doc-example-2.jpg)
  
## Simple arrays with find method
![arrays](Section-2/20-arrays-of-string.jpg)
![arrays](Section-2/21-arrays-filter-by.jpg)

## Array of objects with find method
to use find in embedded document you have to use ".":
`find({"status.description": "your_value"})`

description is an embedded document inside status.  
Pay attention that you must use double quotation around `status.description`.

![arrays](Section-2/22-arrays-filter-by.jpg)
![arrays](Section-2/23-arrays-filter-by.jpg)

</details>

<details>
<summary>Section - 3: Schema Basis</summary>

![schema](Section-3/1-schema.jpg)
![schema](Section-3/2-schemaless-to-sqlworld.jpg)
![schema](Section-3/3-schemaless-to-sqlworld-2.jpg)

* SQL Approach (the same structure for all documents):  
You can assign null to your property. The value of such property will not be assign, but the property will be shown
in your data structure.
`db.products.insertOne({name: "Book", details: null})`

</details>

<details>
<summary>Section - 3: Data Schemas, Data Modelling</summary>

![data-modelling](Section-3/6-data-modelling.jpg)
</details>

<details>
<summary>Section - 3: Data Types, Limits and Statistic</summary>

[good link about how mongodb works inside](https://www.datadoghq.com/blog/monitoring-mongodb-performance-metrics-mmap/)

* Data Types:
![types](Section-3/4-Value-types.jpg)

* to get statistic from your database you have to use `stats()` command;
![stats](Section-3/5-stats.jpg)
To prove that it stores a number instead of float you can use `typeof db.numbers.findOne().a` command.

* MongoDB has a couple of hard limits - most importantly, a single document in a collection (including all embedded documents it might have) must be <= 16mb. Additionally, you may only have 100 levels of embedded documents.
[additional-info](https://docs.mongodb.com/manual/reference/bson-types/)

1. NumberDecimal creates a high-precision double value => NumberDecimal("12.99")
2. NumberInt creates a int32 value => NumberInt(55)
3. NumberLong creates a int64 value => NumberLong(7489729384792)

</details>

<details>
<summary>Section - 3: Relations</summary>

##One to One Relations
![relations](Section-3/7-relations-1.jpg)
![onetoone](Section-3/one-to-one/8-relations-one-to-one-1.jpg)
![onetoone](Section-3/one-to-one/9-relations-one-to-one-2.jpg)

* Example with one-to-one relations and call the data using two steps and variable:

![onetoone](Section-3/one-to-one/10-relations-one-to-one-3.jpg)

It's not the best option of storing data. In such case better to store data like embedded data inside patient document.
In most cases better to use embedded approach. 

* Another one-to-one examples, but using references. You still opt to use different collections: 
It could be possible useful if you try to analyze your data. And it's very good if your data stores in different
collections (for load balancing, for example. Or because we are interesting only in cars).

![onetoone](Section-3/one-to-one/11-relations-one-to-one-reference-4.jpg)
![onetoone](Section-3/one-to-one/12-relations-one-to-one-reference-5.jpg)

##One to Many Relations
![onetomany](Section-3/one-to-many/1-one-to-many-schema-1.jpg)
* And brief example of ref and embedded approaches:

![onetomany](Section-3/one-to-many/2-one-to-many-approaches.jpg)
* Additional example:

![onetomany](Section-3/one-to-many/3-additional-example.jpg)

##Many to Many Relations
![manytomany](Section-3/many-to-many/1-collection-relations.jpg)
* Sql World approach with 3 tables, one of them stores a joint data:

![manytomany](Section-3/many-to-many/2-sql-world-approach.jpg)

* MongoDB Approach:

![manytomany](Section-3/many-to-many/3-mongo-db-approach.jpg)

It allows us to use references within one of the data tables.
Advantages from sql and mongo worlds.
Also no reason to use fully embedded approach for some reasons (over-fetching, possible not up-to-date data and so on).

* Summary:
![summary](Section-3/many-to-many/4-summary.jpg)

## Merging And Joining with $lookup()
![aggregate](Section-3/8-merge-aggregate-lookup.jpg)
* Initial doc is:

![aggregate](Section-3/9-merge-aggregate-lookup2.jpg)
* And the result of aggregate + lookup operator:

![aggregate](Section-3/10-merge-aggregate-lookup3.jpg)

</details>

<details>
<summary>Section - 3: Schema Validation</summary>

![validation](Section-3/validation/1-validation-schema.jpg)
![validation](Section-3/validation/2-levels-and-actions.jpg)

* To declare validation for new collection you have to use explicit collection creation using `createCollection` method.
first  parameter is a new collection name.  
second parameter is its structure: validator + $jsonSchema = validate the schema.
1. Right now $jsonSchema is strongly recommended approach.
2. bsonType: "object" - every coming element should be object-like.
3. required: [] - array of required fields.
4. description - error message.
5. items - you can define nested elements validation.
6. validationAction: 'warn' - only warns you about errors in validation, but not blocks you to send a new document.
<pre>
db.createCollection("newNameOfCollection", {
validator: {
    $jsonSchema: {bsonType: "object", required: ["title", "text", "creator", "comments"], 
    properties: {
     title: { bsonTYpe: "string", description: "must be a string and is required" },
     text: { bsonType: "string", description: "must be a string and is required" },
     creator: { bsonTYpe: "objectId", description: "must be an object and is required" },
     comments: { 
        bsonTYpe: "array",
        description: "must be an array!"
        items: { 
            bsonType: "object",
            required: ["text", "authors"] 
            properties: {
                 text: {
                     bsonType: "string",
                     description: "text must be a string!!"
                 },
                 author: {
                     bsonType: "objectId",
                     description: "author must be an objectId"
                 }
               }
            }
        }
    }
}})
</pre>

* To add\modify validation to already existed collection you have to:
<pre>
db.runCommand({
    collMod: "posts",
    validator: { ...YOUR_VALIDATION_STRUCTURE_AS WE DID BEFORE }
    validationAction: 'warn'
    })
</pre>

this code will succeed. You could see a warning in the log file.(next lecture).

</details>

<details>
<summary>Section 4: MongoDB Settings (As Process and Service), Configuring DB, Log Path</summary>

#### mongod parameters

`--directoryperdb` - each db will be stored in a separate directory (under defined by --dbpath)
 Instead of collection of files - collection of nested folders.

* Linux:
`--fork` - fork process. Works only for Linux. 
[mongodb start vs mongod --fork](https://stackoverflow.com/questions/21329618/whats-the-difference-between-service-mongodb-start-and-mongod/48459859)
to kill MongoDB service process: `use admin` to switch to admin database. And `db.shutdownServer()`;

* Windows:
To run background MongoDB as background service: `net start MongoDB`.  
This command provides you ability to run Mongo as background service.
to kill MongoDB service process: `net stop MongoDB`.

### Save your configurations into configuration file and use it
[configuration file example](Section-4/mongod-configuration-example.cfg)  
To use config file with mongod:
`mongod --config C:/mongod-configuration-example.cfg`
or
`mongod --f C:/mongod-configuration-example.cfg`

It allows you to make a snapshot or blueprint of your mongod configurations.  
Another useful information could be found at mongodb documentation.

### Help
to use help just type help:  
`help admin` - administrative help  
`help connect` - connecting to a db help  
`help keys` - key shortcut
`help misc` - misc things to know
`help mr` - mapreduce.

</details>

<details>
<summary>Section 5: Using the MongoDB Compass to Explore Data Visually</summary>

The MongoDB Compass Docs:   
[https://docs.mongodb.com/compass/master/install/](https://docs.mongodb.com/compass/master/install/)  
Full free version of CompassDB is available free for community.

You can use compass to create databases, collections and documents.
![example](Section-5/1-compass-collection-creation-insert-document.jpg)
Additional features:
![features in compass](Section-5/2-tabs.jpg)

</details>

<details>
<summary>Section 6: CREATE operation, importing documents, additional information</summary>

Available methods:
![methods](Section-6/1-available-methods.jpg)

### Insert
* insert method also works, but not recommended.

* For example after using `db.persons.insert({name: "Phil", age: 25})` you do now await that this new person has an Id, but it has.  
Unlike the insertOne method insert does not show you its new "_id". It could be a real disadvantage, because in real create
operations you want to get an Id of just created object and then - immediately use it in your app (It's an extremely helpful in most cases).

The same story vs insertMany. Its output is not very helpful at all:
![insertmany](Section-6/2-insert.jpg)

### InsertMany
If you use insertMany and send elements with non-unique declared "_id" field - it will raise an error, 
but all elements until <b>first</b> error will be successfully added.  
 
* For example, this one will fail after trying to add "cooking" again:
![insertmany](Section-6/3-insert-many.jpg)
![insertmany](Section-6/4-insert-many.jpg)
* It does not rollback elements which succeeded in inserting.

* To change this behavior you have to use second argument in insertMany method, <b>ordered</b>:  
ordered option will specify how your insert works. If you set it to `ordered: false` all your elements except failed will be inserted.  
In other words, it will continue inserting after fail.
![insertmany-ordered-false](Section-6/5-insertmany-ordered-false.jpg)

* Tip: To Rollback your insert entirely you have to use transactions from transaction module.

### WriteConcern
![writeconcern](Section-6/6-w-j-parameters.jpg)

* What w:0 allows you - it allows you to get immediate response without waiting real data adding to any instance.
The response will be "acknowledge: false" - which means "we are not sure does your request reach the server or not".  
It is super fast, but obviously it does not let you know anything about operations.
![writeconcern](Section-6/7-acknowledge-false.jpg)

* Why storage engine does not store document on the disk first?
because this operation could be quite heavy (take care about indexes, for example), better to store the info into the 
memory first and after that - set it to the disk using "journal ("TODO")".

* Timeout option allows you control create operation time in situations with bad network connection, for example.
in milliseconds.

* Journal parameter (undefined or false is a default parameter):
![journal](Section-6/8-journal.jpg)

### Atomicity
![atomic](Section-6/9-atomic.jpg)

# Importing Data
to import data from json file you have to use mongoimport. This command is available globally (not from mongo terminal mode).
`-d` -database
`-c` -collection name (could be implicitly created)
`--jsonArray` - let your command to know that you send multiple objects, not only one
`--drop` - drop collection before adding (if the collection exist and not empty)
![import](Section-6/10-import-tool.jpg)

</details>


